{"mappings":"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","sources":["<anon>","src/lib/turtle.ts","src/lib/vec2.ts","src/sketches/ch1/02)--turtle-&-lsystem/index.ts","src/sketches/ch1/02)--turtle-&-lsystem/lsystem.ts","src/sketches/ch1/02)--turtle-&-lsystem/grapheme.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4f74\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4f74\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"hbDK6\", function(module, exports) {\n\n$parcel$export(module.exports, \"Turtle\", () => $4babaeeab72245b0$export$8dd83a8c0a56669d);\n\nvar $hdJsM = parcelRequire(\"hdJsM\");\nclass $4babaeeab72245b0$var$State {\n    constructor(position, heading){\n        this.position = position;\n        this.heading = heading;\n    }\n    copy() {\n        return new $4babaeeab72245b0$var$State(this.position.copy(), this.heading);\n    }\n}\nclass $4babaeeab72245b0$export$8dd83a8c0a56669d {\n    constructor(p5, heading){\n        this.p5 = p5;\n        this.state = new $4babaeeab72245b0$var$State((0, $hdJsM.Vec2).of(0, 0), heading == undefined ? -p5.HALF_PI : heading);\n        this.states = [];\n    }\n    push() {\n        this.states.push(this.state.copy());\n        return this;\n    }\n    pop() {\n        this.state = this.states.pop();\n        return this;\n    }\n    move_to(x, y) {\n        this.state.position.x = x;\n        this.state.position.y = y;\n        return this;\n    }\n    line_to(x, y) {\n        this.p5.line(this.state.position.x, this.state.position.y, x, y);\n        this.move_to(x, y);\n        return this;\n    }\n    line_forward(length) {\n        const dx = this.state.position.x + Math.cos(this.state.heading) * length;\n        const dy = this.state.position.y + Math.sin(this.state.heading) * length;\n        this.line_to(dx, dy);\n        return this;\n    }\n    move_forward(length) {\n        const dx = this.state.position.x + Math.cos(this.state.heading) * length;\n        const dy = this.state.position.y + Math.sin(this.state.heading) * length;\n        this.move_to(dx, dy);\n        return this;\n    }\n    turn(angle_in_radians) {\n        this.state.heading += angle_in_radians;\n        return this;\n    }\n    set_heading(angle_in_radians) {\n        this.state.heading = angle_in_radians;\n        return this;\n    }\n}\n\n});\nparcelRegister(\"hdJsM\", function(module, exports) {\n\n$parcel$export(module.exports, \"Vec2\", () => $930c69342eb1435a$export$ac4bca90992eed1);\nclass $930c69342eb1435a$export$ac4bca90992eed1 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    /**\n   * Get a copy of this vector.\n   * @param dest if specified, the values will be saved in dest.\n   * @returns either dest or a new vector\n   */ copy(dest) {\n        if (!dest) return $930c69342eb1435a$export$ac4bca90992eed1.of(this.x, this.y);\n        dest.x = this.x;\n        dest.y = this.y;\n        return dest;\n    }\n    /**\n   * Computes the sum of this vector and the given vector.\n   *\n   * Results are saved inline.\n   *\n   * @param a the vector to sum\n   * @returns this\n   */ sum(a) {\n        this.x += a.x;\n        this.y += a.y;\n        return this;\n    }\n    /**\n   * Multiply this vector by a scalar.\n   *\n   * Results are saved inline.\n   *\n   * @param a the scalar\n   * @returns this\n   */ mult(a) {\n        this.x *= a;\n        this.y *= a;\n        return this;\n    }\n    /**\n   * Normalizes the vector.\n   *\n   * Results are saved inline.\n   *\n   * @returns this\n   */ normalize() {\n        return this.mult(1.0 / this.length());\n    }\n    /**\n   * Computes the squared length of the vector.\n   */ length_squared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n   * Computes the length of the vector.\n   */ length() {\n        return Math.sqrt(this.length_squared());\n    }\n    /**\n   * Computes the dot product between two vectors.\n   *\n   * This vector is not modified.\n   *\n   * @param a\n   * @returns the value of the dot product.\n   */ dot(a) {\n        return this.x * a.x + this.y * a.y;\n    }\n    // STATIC METHODS ----------------------------------------------\n    /**\n   * Allocates a new vector.\n   * @param x the x coordinate\n   * @param y the y coordinate\n   * @returns the vector\n   */ static of(x, y) {\n        return new $930c69342eb1435a$export$ac4bca90992eed1(x, y);\n    }\n}\n\n});\n\n\n\nvar $7vzAp = parcelRequire(\"7vzAp\");\n\nvar $9DS0H = parcelRequire(\"9DS0H\");\n\nvar $hbDK6 = parcelRequire(\"hbDK6\");\n/**\n * A Grapheme is the smallest meaningful unit in the writing system.\n *\n * Graphemes can be any object, as long as it can be identified by a string.\n */ function $7114e73d151cd97e$export$1c9f709888824e05(axiom) {\n    return axiom.reduce((total, current)=>{\n        return total + current.id;\n    }, `${axiom.length}:`);\n}\nfunction $7114e73d151cd97e$export$67beed298888a38b(axiom, actions) {\n    for (const g of axiom){\n        const action = actions[g.id];\n        if (action != undefined) action(g);\n    }\n}\nconst $7114e73d151cd97e$export$1ea9e0c3db095f97 = {\n    /**\n   * Creates a new Grapheme instance with the given string id.\n   * @param str the Grapheme's id.\n   * @returns a new Grapheme instance.\n   */ of: (str)=>{\n        return {\n            id: str\n        };\n    },\n    /**\n   * Splits a string into Graphemes.\n   *\n   * Each Grapheme is identified by a single character in the provided string.\n   *\n   * @param str the string or template string which needs to be split\n   * @returns a list of new Graphemes, each identified by a single character.\n   */ chars: (str)=>{\n        const result = [];\n        for (const c of str)result.push({\n            id: c\n        });\n        return result;\n    }\n};\n\n\nclass $6d130f619cfe737a$export$2bf3081bedff6dc4 {\n    constructor(rules){\n        this._axiom = [];\n        this.rules = rules;\n    }\n    // Public API ---------------------------------------------------------------\n    get axiom() {\n        return this._axiom;\n    }\n    set axiom(axiom) {\n        if (typeof axiom == \"string\" || axiom instanceof String) this._axiom = (0, $7114e73d151cd97e$export$1ea9e0c3db095f97).chars(axiom);\n        else this._axiom = [\n            ...axiom\n        ];\n    }\n    /**\n   * Apply the rules to produce the next axiom.\n   *\n   * Results can be inspected by calling this.axiom.\n   */ produce() {\n        const next_axiom = [];\n        for (const predecessor of this._axiom)next_axiom.push(...this.compute_successors(predecessor));\n        this._axiom = next_axiom;\n    }\n    // Private API --------------------------------------------------------------\n    /**\n   * Uses the production rules to compute the array of Grapheme[] successors.\n   */ compute_successors(predecessor) {\n        const successor = this.rules[predecessor.id];\n        if (successor == undefined) return [\n            predecessor\n        ];\n        else if (typeof successor == \"string\" || successor instanceof String) return (0, $7114e73d151cd97e$export$1ea9e0c3db095f97).chars(successor);\n        else if (Array.isArray(successor)) return successor;\n        else return successor(predecessor);\n    }\n}\n\n\n\nfunction $775a36a10be31b77$var$sketch(p5) {\n    const w = window.innerWidth * 0.75;\n    const h = window.innerHeight * 0.75;\n    const l_system = new (0, $6d130f619cfe737a$export$2bf3081bedff6dc4)({\n        F: \"F-F+F+FF-F-F+F\"\n    });\n    let count = 10;\n    p5.setup = ()=>{\n        p5.createCanvas(w, h);\n    };\n    p5.draw = ()=>{\n        if (count++ >= 3) {\n            count = 0;\n            l_system.axiom = \"F-F-F-F\";\n            p5.frameRate(1);\n        } else {\n            l_system.produce();\n            console.log((0, $7114e73d151cd97e$export$1c9f709888824e05)(l_system.axiom));\n        }\n        p5.background($9DS0H.antique_white(p5));\n        const turtle = new (0, $hbDK6.Turtle)(p5).move_to(w / 3, 3 * h / 4);\n        const distance = w / 3 * Math.pow(1 / 4, count);\n        const theta = p5.HALF_PI;\n        (0, $7114e73d151cd97e$export$67beed298888a38b)(l_system.axiom, {\n            F: ()=>turtle.line_forward(distance),\n            \"-\": ()=>turtle.turn(theta),\n            \"+\": ()=>turtle.turn(-theta)\n        });\n    };\n}\nnew (0, $7vzAp.Page)(\"Turtle & LSystem\", $775a36a10be31b77$var$sketch);\n\n\n//# sourceMappingURL=index.e966ad76.js.map\n","import P5 from \"p5\";\nimport { Vec2 } from \"~/src/lib/vec2\";\n\nclass State {\n  public position: Vec2;\n  public heading: number;\n\n  constructor(position: Vec2, heading: number) {\n    this.position = position;\n    this.heading = heading;\n  }\n\n  public copy(): State {\n    return new State(this.position.copy(), this.heading);\n  }\n}\n\nexport class Turtle {\n  private p5: P5;\n  private state: State;\n  private states: State[];\n\n  constructor(p5: P5, heading?: number) {\n    this.p5 = p5;\n    this.state = new State(\n      Vec2.of(0, 0),\n      heading == undefined ? -p5.HALF_PI : heading\n    );\n    this.states = [];\n  }\n\n  push(): Turtle {\n    this.states.push(this.state.copy());\n    return this;\n  }\n\n  pop(): Turtle {\n    this.state = this.states.pop();\n    return this;\n  }\n\n  move_to(x: number, y: number): Turtle {\n    this.state.position.x = x;\n    this.state.position.y = y;\n    return this;\n  }\n\n  line_to(x: number, y: number): Turtle {\n    this.p5.line(this.state.position.x, this.state.position.y, x, y);\n    this.move_to(x, y);\n    return this;\n  }\n\n  line_forward(length: number): Turtle {\n    const dx = this.state.position.x + Math.cos(this.state.heading) * length;\n    const dy = this.state.position.y + Math.sin(this.state.heading) * length;\n    this.line_to(dx, dy);\n    return this;\n  }\n\n  move_forward(length: number): Turtle {\n    const dx = this.state.position.x + Math.cos(this.state.heading) * length;\n    const dy = this.state.position.y + Math.sin(this.state.heading) * length;\n    this.move_to(dx, dy);\n    return this;\n  }\n\n  turn(angle_in_radians: number): Turtle {\n    this.state.heading += angle_in_radians;\n    return this;\n  }\n\n  set_heading(angle_in_radians: number): Turtle {\n    this.state.heading = angle_in_radians;\n    return this;\n  }\n}\n","export class Vec2 {\n  public x: number;\n  public y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Get a copy of this vector.\n   * @param dest if specified, the values will be saved in dest.\n   * @returns either dest or a new vector\n   */\n  copy(dest?: Vec2): Vec2 {\n    if (!dest) {\n      return Vec2.of(this.x, this.y);\n    }\n    dest.x = this.x;\n    dest.y = this.y;\n    return dest;\n  }\n\n  /**\n   * Computes the sum of this vector and the given vector.\n   *\n   * Results are saved inline.\n   *\n   * @param a the vector to sum\n   * @returns this\n   */\n  public sum(a: Vec2): Vec2 {\n    this.x += a.x;\n    this.y += a.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * Results are saved inline.\n   *\n   * @param a the scalar\n   * @returns this\n   */\n  public mult(a: number): Vec2 {\n    this.x *= a;\n    this.y *= a;\n    return this;\n  }\n\n  /**\n   * Normalizes the vector.\n   *\n   * Results are saved inline.\n   *\n   * @returns this\n   */\n  public normalize(): Vec2 {\n    return this.mult(1.0 / this.length());\n  }\n\n  /**\n   * Computes the squared length of the vector.\n   */\n  public length_squared(): number {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  /**\n   * Computes the length of the vector.\n   */\n  public length(): number {\n    return Math.sqrt(this.length_squared());\n  }\n\n  /**\n   * Computes the dot product between two vectors.\n   *\n   * This vector is not modified.\n   *\n   * @param a\n   * @returns the value of the dot product.\n   */\n  public dot(a: Vec2): number {\n    return this.x * a.x + this.y * a.y;\n  }\n\n  // STATIC METHODS ----------------------------------------------\n\n  /**\n   * Allocates a new vector.\n   * @param x the x coordinate\n   * @param y the y coordinate\n   * @returns the vector\n   */\n  public static of(x: number, y: number): Vec2 {\n    return new Vec2(x, y);\n  }\n}\n","import { Page } from \"~/src/lib/page\";\nimport * as palette from \"~/src/lib/palette\";\nimport P5 from \"p5\";\nimport { Turtle } from \"~src/lib/turtle\";\nimport { LSystem } from \"./lsystem\";\nimport { debug, interpret } from \"./grapheme\";\n\nfunction sketch(p5: P5) {\n  const w = window.innerWidth * 0.75;\n  const h = window.innerHeight * 0.75;\n\n  const l_system = new LSystem({\n    F: \"F-F+F+FF-F-F+F\",\n  });\n\n  let count = 10;\n\n  p5.setup = () => {\n    p5.createCanvas(w, h);\n  };\n  p5.draw = () => {\n    if (count++ >= 3) {\n      count = 0;\n      l_system.axiom = \"F-F-F-F\";\n      p5.frameRate(1);\n    } else {\n      l_system.produce();\n      console.log(debug(l_system.axiom));\n    }\n\n    p5.background(palette.antique_white(p5));\n\n    const turtle = new Turtle(p5).move_to(w / 3, (3 * h) / 4);\n    const distance = (w / 3) * Math.pow(1 / 4, count);\n    const theta = p5.HALF_PI;\n\n    interpret(l_system.axiom, {\n      F: () => turtle.line_forward(distance),\n      \"-\": () => turtle.turn(theta),\n      \"+\": () => turtle.turn(-theta),\n    });\n  };\n}\n\nnew Page(\"Turtle & LSystem\", sketch);\n","import { Grapheme, CharGrapheme as CG } from \"./grapheme\";\n\n/**\n * Processes a Grapheme to generate an output.\n */\nexport type SuccessorFn = (g: Grapheme) => Grapheme[];\n\n/**\n * A Successor is the result of applying a production rule to a Grapheme.\n *\n * Successors take one of three forms:\n *\n * * string\n *     A string successor is automatically split into Graphemes where\n *     each character is a separate Id.\n * * Grapheme[]\n *     An array of Graphemes is interpreted as the direct result of\n *     transforming the predecessor Grapheme.\n * * SuccessorFn\n *     A SuccessorFn is given the original grapheme object and can produce an\n *     arbitrary Grapheme[] array as output.\n */\nexport type Successor = string | Grapheme[] | SuccessorFn;\n\n/**\n * Production rules map a predecessor to a resulting list of Graphemes.\n *\n * The predecessor Grapheme is identified by its Id string.\n */\nexport interface ProductionRules {\n  [predecessor: string]: Successor;\n}\n\n/**\n * A Lindenmayer System implementation.\n * https://en.wikipedia.org/wiki/L-system\n */\nexport class LSystem {\n  private _axiom: Grapheme[];\n  private rules: ProductionRules;\n\n  constructor(rules: ProductionRules) {\n    this._axiom = [];\n    this.rules = rules;\n  }\n\n  // Public API ---------------------------------------------------------------\n\n  public get axiom(): Grapheme[] {\n    return this._axiom;\n  }\n\n  public set axiom(axiom: Grapheme[] | string) {\n    if (typeof axiom == \"string\" || axiom instanceof String) {\n      this._axiom = CG.chars(axiom as string);\n    } else {\n      this._axiom = [...axiom];\n    }\n  }\n\n  /**\n   * Apply the rules to produce the next axiom.\n   *\n   * Results can be inspected by calling this.axiom.\n   */\n  public produce() {\n    const next_axiom: Grapheme[] = [];\n    for (const predecessor of this._axiom) {\n      next_axiom.push(...this.compute_successors(predecessor));\n    }\n    this._axiom = next_axiom;\n  }\n\n  // Private API --------------------------------------------------------------\n\n  /**\n   * Uses the production rules to compute the array of Grapheme[] successors.\n   */\n  private compute_successors(predecessor: Grapheme): Grapheme[] {\n    const successor = this.rules[predecessor.id];\n    if (successor == undefined) {\n      return [predecessor];\n    } else if (typeof successor == \"string\" || successor instanceof String) {\n      return CG.chars(successor as string);\n    } else if (Array.isArray(successor)) {\n      return successor;\n    } else {\n      return successor(predecessor);\n    }\n  }\n}\n","/**\n * A Grapheme is the smallest meaningful unit in the writing system.\n *\n * Graphemes can be any object, as long as it can be identified by a string.\n */\nexport interface Grapheme {\n  /**\n   * A unique identifier for the Grapheme.\n   *\n   * IDs are used for comparing Graphemes.\n   */\n  readonly id: string;\n}\n\n/**\n * Generates a readable string based on the axiom.\n * @param axiom an array of Graphemes.\n * @returns a human-readable string describing the axiom\n */\nexport function debug(axiom: Grapheme[]): string {\n  return axiom.reduce((total: string, current: Grapheme) => {\n    return total + current.id;\n  }, `${axiom.length}:`);\n}\n\n/**\n * A set of actions to take while processing an array of Graphemes.\n */\nexport interface Actions {\n  [id: string]: (g: Grapheme) => void;\n}\n\n/**\n * Process an axiom by interpreting each Grapheme in order.\n *\n * Graphemes which have no associated action are simply ignored.\n *\n * @param axiom the array of Graphemes to process.\n * @param actions an object which maps Grapheme ids to functions\n */\nexport function interpret(axiom: Grapheme[], actions: Actions) {\n  for (const g of axiom) {\n    const action = actions[g.id];\n    if (action != undefined) {\n      action(g);\n    }\n  }\n}\n\n/**\n * Helper function for constructing single character graphemes.\n */\nexport const CharGrapheme = {\n  /**\n   * Creates a new Grapheme instance with the given string id.\n   * @param str the Grapheme's id.\n   * @returns a new Grapheme instance.\n   */\n  of: (str: string): Grapheme => {\n    return { id: str };\n  },\n\n  /**\n   * Splits a string into Graphemes.\n   *\n   * Each Grapheme is identified by a single character in the provided string.\n   *\n   * @param str the string or template string which needs to be split\n   * @returns a list of new Graphemes, each identified by a single character.\n   */\n  chars: (str: string): Grapheme[] => {\n    const result = [];\n    for (const c of str) {\n      result.push({ id: c });\n    }\n    return result;\n  },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$4babaeeab72245b0$export$8dd83a8c0a56669d","$hdJsM","$4babaeeab72245b0$var$State","constructor","position","heading","copy","p5","state","Vec2","of","undefined","HALF_PI","states","push","pop","move_to","x","y","line_to","line","line_forward","length","dx","Math","cos","dy","sin","move_forward","turn","angle_in_radians","set_heading","$930c69342eb1435a$export$ac4bca90992eed1","dest","sum","a","mult","normalize","length_squared","sqrt","dot","$7vzAp","$9DS0H","$hbDK6","$7114e73d151cd97e$export$1ea9e0c3db095f97","str","chars","result","c","$6d130f619cfe737a$export$2bf3081bedff6dc4","rules","_axiom","axiom","String","produce","next_axiom","predecessor","compute_successors","successor","Array","isArray","Page","w","window","innerWidth","h","innerHeight","l_system","F","count","setup","createCanvas","draw","frameRate","console","log","reduce","total","current","background","antique_white","turtle","Turtle","distance","pow","theta","actions","g","action"],"version":3,"file":"index.e966ad76.js.map"}